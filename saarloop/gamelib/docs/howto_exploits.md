[(back to gamelib manual)](../README.md)

HowTo Exploits
==============

Writing demo exploits is easy. There is no special requirement, except that it should be python3 and accept a target IP as first argument.
Stolen flags should be printed, no formatting or cleanup is required (we use regexp to parse them from your output).

If flag IDs are configured, they are passed as additional arguments: `sys.argv[2]` contains the first flag IDs, comma-separated.

```python
import sys
from typing import List

# Checker is configured with:  flag_id_types = ['username', 'hex12']

def exploit(target: str, flag_ids_username: List[str], flag_ids_hex: List[str]):
    for flag_id in flag_ids_username:
        print(f'Attacking {flag_id}')
        result = ...
        print(result)


if __name__ == '__main__':
    exploit(sys.argv[1], sys.argv[2].split(','), sys.argv[3].split(','))
```

Our CI tests all exploits named `exploit_<???>.py` in `./exploits/`. Use `gamelib/run-exploits` to check locally. 
A working checkerscript is required to test exploits, otherwise there will not be any flags stored.

Please write one exploit per vulnerability.  


Additional Dependencies
-----------------------
If you need additional software to perform an exploit (python modules, system packages) you can install them in your service's `dependencies.sh`. 

1. Please check first if the package you need is already preinstalled. 
2. Then check if the package can be installed from Debian Bullseye's repository (using `apt`). 
   These packages are usually more stable and don't change that often.
3. If not, you can freely use `python3 -m pip install`. 

We have preinstalled (at least): 
- Python3 with pip
- redis
- requests
- pwntools
- numpy
- pycryptodome
- beautifulsoup4
- pytz


Checker Interaction
-------------------
Some exploits might require interaction with the checker server, 
for example if the vulnerability is only exploitable while the gameserver retrieves the flag.
This special case can be handled by copying the following function in your exploit:
```python
import os

def wait_for_checker_to_retrieve_flags(target):
    """
    In our CI environment, the environment variable "CHECKER_RETRIEVE_CMD" triggers the checker to retrieve flags again
    (for exploits that catch the flag in-flight).
    """
    print('-' * 80)
    print('waiting for checker ...')
    sys.stdout.flush()
    if 'CHECKER_RETRIEVE_CMD' in os.environ:
        os.system(os.environ['CHECKER_RETRIEVE_CMD'] + " 2>&1 | tac | tac | sed 's/SAAR{/SAAR_/'")
    else:
        # Trigger the regular checker script with some parameters (adjust for your own testing)
        os.system(f"PYTHONPATH=../ python3 -u ../checkers/interface.py '{target}' retrieve")
    print('-' * 80)
```

Call `wait_for_checker_to_retrieve_flags(target)` when your exploit is ready and waiting for gameserver interaction. 
It will retrieve the last 10 flags stored. When the gameserver is finished retrieving, the function returns.
You can freely adjust the second command (after `else`) to suit your personal testing habits.
